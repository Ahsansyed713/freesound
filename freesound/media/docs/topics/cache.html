<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Django&#8217;s cache framework &mdash; Django v1.0 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="Django v1.0 documentation" href="../index.html" />
    <link rel="up" title="Using Django" href="index.html" />
    <link rel="next" title="Sending e-mail" href="email.html" />
    <link rel="prev" title="User authentication in Django" href="auth.html" /> 
  </head>
  <body>
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../index.html">Django v1.0 documentation</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../index.html">Home</a>  |
        <a title="Table of contents" href="../contents.html">Table of contents</a>  |
        <a title="Global index" href="../genindex.html">Index</a>  |
        <a title="Search" href="../modindex.html">Modules</a>
      </div>
      <div class="nav">
    &laquo; <a href="auth.html" title="User authentication in Django">previous</a> 
     |
    <a href="index.html" title="Using Django" accesskey="U">up</a>
   |
    <a href="email.html" title="Sending e-mail">next</a> &raquo;</div>
    </div>
    
    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="topics-cache">
            
  
  <div class="section" id="s-django-s-cache-framework">
<span id="s-topics-cache"></span><span id="django-s-cache-framework"></span><span id="topics-cache"></span><h1>Django&#8217;s cache framework<a class="headerlink" href="#django-s-cache-framework" title="Permalink to this headline">¶</a></h1>
<p>A fundamental trade-off in dynamic Web sites is, well, they&#8217;re dynamic. Each
time a user requests a page, the Web server makes all sorts of calculations &#8211;
from database queries to template rendering to business logic &#8211; to create the
page that your site&#8217;s visitor sees. This is a lot more expensive, from a
processing-overhead perspective, than your standard
read-a-file-off-the-filesystem server arrangement.</p>
<p>For most Web applications, this overhead isn&#8217;t a big deal. Most Web
applications aren&#8217;t washingtonpost.com or slashdot.org; they&#8217;re simply small-
to medium-sized sites with so-so traffic. But for medium- to high-traffic
sites, it&#8217;s essential to cut as much overhead as possible.</p>
<p>That&#8217;s where caching comes in.</p>
<p>To cache something is to save the result of an expensive calculation so that
you don&#8217;t have to perform the calculation next time. Here&#8217;s some pseudocode
explaining how this would work for a dynamically generated Web page:</p>
<div class="highlight-python"><pre>given a URL, try finding that page in the cache
if the page is in the cache:
    return the cached page
else:
    generate the page
    save the generated page in the cache (for next time)
    return the generated page</pre>
</div>
<p>Django comes with a robust cache system that lets you save dynamic pages so
they don't have to be calculated for each request. For convenience, Django
offers different levels of cache granularity: You can cache the output of
specific views, you can cache only the pieces that are difficult to produce, or
you can cache your entire site.</p>
<p>Django also works well with &quot;upstream&quot; caches, such as Squid
(<a class="reference external" href="http://www.squid-cache.org/">http://www.squid-cache.org/</a>) and browser-based caches. These are the types of
caches that you don't directly control but to which you can provide hints (via
HTTP headers) about which parts of your site should be cached, and how.</p>
<div class="section" id="s-setting-up-the-cache">
<span id="setting-up-the-cache"></span><h2>Setting up the cache<a class="headerlink" href="#setting-up-the-cache" title="Permalink to this headline">¶</a></h2>
<p>The cache system requires a small amount of setup. Namely, you have to tell it
where your cached data should live -- whether in a database, on the filesystem
or directly in memory. This is an important decision that affects your cache's
performance; yes, some cache types are faster than others.</p>
<p>Your cache preference goes in the <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt> setting in your settings
file. Here's an explanation of all available values for CACHE_BACKEND.</p>
<div class="section" id="s-memcached">
<span id="memcached"></span><h3>Memcached<a class="headerlink" href="#memcached" title="Permalink to this headline">¶</a></h3>
<p>By far the fastest, most efficient type of cache available to Django, Memcached
is an entirely memory-based cache framework originally developed to handle high
loads at LiveJournal.com and subsequently open-sourced by Danga Interactive.
It's used by sites such as Slashdot and Wikipedia to reduce database access and
dramatically increase site performance.</p>
<p>Memcached is available for free at <a class="reference external" href="http://danga.com/memcached/">http://danga.com/memcached/</a> . It runs as a
daemon and is allotted a specified amount of RAM. All it does is provide an
interface -- a <em>super-lightning-fast</em> interface -- for adding, retrieving and
deleting arbitrary data in the cache. All data is stored directly in memory,
so there's no overhead of database or filesystem usage.</p>
<p>After installing Memcached itself, you'll need to install the Memcached Python
bindings. Two versions of this are available. Choose and install <em>one</em> of the
following modules:</p>
<ul class="simple">
<li>The fastest available option is a module called <tt class="docutils literal"><span class="pre">cmemcache</span></tt>, available
at <a class="reference external" href="http://gijsbert.org/cmemcache/">http://gijsbert.org/cmemcache/</a> .</li>
<li>If you can't install <tt class="docutils literal"><span class="pre">cmemcache</span></tt>, you can install <tt class="docutils literal"><span class="pre">python-memcached</span></tt>,
available at <a class="reference external" href="ftp://ftp.tummy.com/pub/python-memcached/">ftp://ftp.tummy.com/pub/python-memcached/</a> . If that URL is
no longer valid, just go to the Memcached Web site
(<a class="reference external" href="http://www.danga.com/memcached/">http://www.danga.com/memcached/</a>) and get the Python bindings from the
&quot;Client APIs&quot; section.</li>
</ul>
<div class="versionadded">
<span class="title">New in Django 1.0:</span> The <tt class="docutils literal"><span class="pre">cmemcache</span></tt> option is new in 1.0. Previously, only
<tt class="docutils literal"><span class="pre">python-memcached</span></tt> was supported.</div>
<p>To use Memcached with Django, set <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt> to
<tt class="docutils literal"><span class="pre">memcached://ip:port/</span></tt>, where <tt class="docutils literal"><span class="pre">ip</span></tt> is the IP address of the Memcached
daemon and <tt class="docutils literal"><span class="pre">port</span></tt> is the port on which Memcached is running.</p>
<p>In this example, Memcached is running on localhost (127.0.0.1) port 11211:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;memcached://127.0.0.1:11211/&#39;</span>
</pre></div>
</div>
<p>One excellent feature of Memcached is its ability to share cache over multiple
servers. To take advantage of this feature, include all server addresses in
<tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt>, separated by semicolons. In this example, the cache is
shared over Memcached instances running on IP address 172.19.26.240 and
172.19.26.242, both on port 11211:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;memcached://172.19.26.240:11211;172.19.26.242:11211/&#39;</span>
</pre></div>
</div>
<p>Memory-based caching has one disadvantage: Because the cached data is stored in
memory, the data will be lost if your server crashes. Clearly, memory isn't
intended for permanent data storage, so don't rely on memory-based caching as
your only data storage. Actually, none of the Django caching backends should be
used for permanent storage -- they're all intended to be solutions for caching,
not storage -- but we point this out here because memory-based caching is
particularly temporary.</p>
</div>
<div class="section" id="s-database-caching">
<span id="database-caching"></span><h3>Database caching<a class="headerlink" href="#database-caching" title="Permalink to this headline">¶</a></h3>
<p>To use a database table as your cache backend, first create a cache table in
your database by running this command:</p>
<div class="highlight-python"><pre>python manage.py createcachetable [cache_table_name]</pre>
</div>
<p>...where <tt class="docutils literal"><span class="pre">[cache_table_name]</span></tt> is the name of the database table to create.
(This name can be whatever you want, as long as it's a valid table name that's
not already being used in your database.) This command creates a single table
in your database that is in the proper format that Django's database-cache
system expects.</p>
<p>Once you've created that database table, set your <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt> setting to
<tt class="docutils literal"><span class="pre">&quot;db://tablename&quot;</span></tt>, where <tt class="docutils literal"><span class="pre">tablename</span></tt> is the name of the database table.
In this example, the cache table's name is <tt class="docutils literal"><span class="pre">my_cache_table</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;db://my_cache_table&#39;</span>
</pre></div>
</div>
<p>Database caching works best if you've got a fast, well-indexed database server.</p>
</div>
<div class="section" id="s-filesystem-caching">
<span id="filesystem-caching"></span><h3>Filesystem caching<a class="headerlink" href="#filesystem-caching" title="Permalink to this headline">¶</a></h3>
<p>To store cached items on a filesystem, use the <tt class="docutils literal"><span class="pre">&quot;file://&quot;</span></tt> cache type for
<tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt>. For example, to store cached data in <tt class="docutils literal"><span class="pre">/var/tmp/django_cache</span></tt>,
use this setting:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;file:///var/tmp/django_cache&#39;</span>
</pre></div>
</div>
<p>Note that there are three forward slashes toward the beginning of that example.
The first two are for <tt class="docutils literal"><span class="pre">file://</span></tt>, and the third is the first character of the
directory path, <tt class="docutils literal"><span class="pre">/var/tmp/django_cache</span></tt>.</p>
<p>The directory path should be absolute -- that is, it should start at the root
of your filesystem. It doesn't matter whether you put a slash at the end of the
setting.</p>
<p>Make sure the directory pointed-to by this setting exists and is readable and
writable by the system user under which your Web server runs. Continuing the
above example, if your server runs as the user <tt class="docutils literal"><span class="pre">apache</span></tt>, make sure the
directory <tt class="docutils literal"><span class="pre">/var/tmp/django_cache</span></tt> exists and is readable and writable by the
user <tt class="docutils literal"><span class="pre">apache</span></tt>.</p>
</div>
<div class="section" id="s-local-memory-caching">
<span id="local-memory-caching"></span><h3>Local-memory caching<a class="headerlink" href="#local-memory-caching" title="Permalink to this headline">¶</a></h3>
<p>If you want the speed advantages of in-memory caching but don't have the
capability of running Memcached, consider the local-memory cache backend. This
cache is multi-process and thread-safe. To use it, set <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt> to
<tt class="docutils literal"><span class="pre">&quot;locmem:///&quot;</span></tt>. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;locmem:///&#39;</span>
</pre></div>
</div>
<p>Note that each process will have its own private cache instance, which means no
cross-process caching is possible. This obviously also means the local memory
cache isn't particularly memory-efficient, so it's probably not a good choice
for production environments.</p>
</div>
<div class="section" id="s-dummy-caching-for-development">
<span id="dummy-caching-for-development"></span><h3>Dummy caching (for development)<a class="headerlink" href="#dummy-caching-for-development" title="Permalink to this headline">¶</a></h3>
<p>Finally, Django comes with a &quot;dummy&quot; cache that doesn't actually cache -- it
just implements the cache interface without doing anything.</p>
<p>This is useful if you have a production site that uses heavy-duty caching in
various places but a development/test environment on which you don't want to
cache. As a result, your development environment won't use caching and your
production environment still will. To activate dummy caching, set
<tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt> like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;dummy:///&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="s-using-a-custom-cache-backend">
<span id="using-a-custom-cache-backend"></span><h3>Using a custom cache backend<a class="headerlink" href="#using-a-custom-cache-backend" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<span class="title">New in Django 1.0.</span> </div>
<p>While Django includes support for a number of cache backends out-of-the-box,
sometimes you might want to use a customized cache backend. To use an external
cache backend with Django, use a Python import path as the scheme portion (the
part before the initial colon) of the <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt> URI, like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;path.to.backend://&#39;</span>
</pre></div>
</div>
<p>If you're building your own backend, you can use the standard cache backends
as reference implementations. You'll find the code in the
<tt class="docutils literal"><span class="pre">django/core/cache/backends/</span></tt> directory of the Django source.</p>
<p>Note: Without a really compelling reason, such as a host that doesn't support
them, you should stick to the cache backends included with Django. They've
been well-tested and are easy to use.</p>
</div>
<div class="section" id="s-cache-backend-arguments">
<span id="cache-backend-arguments"></span><h3>CACHE_BACKEND arguments<a class="headerlink" href="#cache-backend-arguments" title="Permalink to this headline">¶</a></h3>
<p>All caches may take arguments. They're given in query-string style on the
<tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt> setting. Valid arguments are:</p>
<dl class="docutils">
<dt>timeout</dt>
<dd>Default timeout, in seconds, to use for the cache. Defaults to 5
minutes (300 seconds).</dd>
<dt>max_entries</dt>
<dd>For the <tt class="docutils literal"><span class="pre">locmem</span></tt>, <tt class="docutils literal"><span class="pre">filesystem</span></tt> and <tt class="docutils literal"><span class="pre">database</span></tt> backends, the
maximum number of entries allowed in the cache before it is cleaned.
Defaults to 300.</dd>
<dt>cull_percentage</dt>
<dd><p class="first">The percentage of entries that are culled when max_entries is reached.
The actual percentage is 1/cull_percentage, so set cull_percentage=3 to
cull 1/3 of the entries when max_entries is reached.</p>
<p class="last">A value of 0 for cull_percentage means that the entire cache will be
dumped when max_entries is reached. This makes culling <em>much</em> faster
at the expense of more cache misses.</p>
</dd>
</dl>
<p>In this example, <tt class="docutils literal"><span class="pre">timeout</span></tt> is set to <tt class="docutils literal"><span class="pre">60</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&quot;memcached://127.0.0.1:11211/?timeout=60&quot;</span>
</pre></div>
</div>
<p>In this example, <tt class="docutils literal"><span class="pre">timeout</span></tt> is <tt class="docutils literal"><span class="pre">30</span></tt> and <tt class="docutils literal"><span class="pre">max_entries</span></tt> is <tt class="docutils literal"><span class="pre">400</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&quot;locmem:///?timeout=30&amp;max_entries=400&quot;</span>
</pre></div>
</div>
<p>Invalid arguments are silently ignored, as are invalid values of known
arguments.</p>
</div>
</div>
<div class="section" id="s-the-per-site-cache">
<span id="the-per-site-cache"></span><h2>The per-site cache<a class="headerlink" href="#the-per-site-cache" title="Permalink to this headline">¶</a></h2>
<div class="versionchanged">
<span class="title">Changed in Django 1.0:</span> (previous versions of Django only provided a single <tt class="docutils literal"><span class="pre">CacheMiddleware</span></tt> instead
of the two pieces described below).</div>
<p>Once the cache is set up, the simplest way to use caching is to cache your
entire site. You'll need to add
<tt class="docutils literal"><span class="pre">'django.middleware.cache.UpdateCacheMiddleware'</span></tt> and
<tt class="docutils literal"><span class="pre">'django.middleware.cache.FetchFromCacheMiddleware'</span></tt> to your
<tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> setting, as in this example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">MIDDLEWARE_CLASSES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s">&#39;django.middleware.cache.UpdateCacheMiddleware&#39;</span><span class="p">,</span>
    <span class="s">&#39;django.middleware.common.CommonMiddleware&#39;</span><span class="p">,</span>
    <span class="s">&#39;django.middleware.cache.FetchFromCacheMiddleware&#39;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No, that's not a typo: the &quot;update&quot; middleware must be first in the list,
and the &quot;fetch&quot; middleware must be last. The details are a bit obscure, but
see <a class="reference internal" href="#order-of-middleware-classes">Order of MIDDLEWARE_CLASSES</a> below if you'd like the full story.</p>
</div>
<p>Then, add the following required settings to your Django settings file:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_SECONDS</span></tt> -- The number of seconds each page should be
cached.</li>
<li><tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_KEY_PREFIX</span></tt> -- If the cache is shared across multiple
sites using the same Django installation, set this to the name of the site,
or some other string that is unique to this Django instance, to prevent key
collisions. Use an empty string if you don't care.</li>
</ul>
<p>The cache middleware caches every page that doesn't have GET or POST
parameters. Optionally, if the <tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_ANONYMOUS_ONLY</span></tt> setting is
<tt class="xref docutils literal"><span class="pre">True</span></tt>, only anonymous requests (i.e., not those made by a logged-in user)
will be cached. This is a simple and effective way of disabling caching for any
user-specific pages (include Django's admin interface). Note that if you use
<tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_ANONYMOUS_ONLY</span></tt>, you should make sure you've activated
<tt class="docutils literal"><span class="pre">AuthenticationMiddleware</span></tt>.</p>
<p>Additionally, the cache middleware automatically sets a few headers in each
<tt class="docutils literal"><span class="pre">HttpResponse</span></tt>:</p>
<ul class="simple">
<li>Sets the <tt class="docutils literal"><span class="pre">Last-Modified</span></tt> header to the current date/time when a fresh
(uncached) version of the page is requested.</li>
<li>Sets the <tt class="docutils literal"><span class="pre">Expires</span></tt> header to the current date/time plus the defined
<tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_SECONDS</span></tt>.</li>
<li>Sets the <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> header to give a max age for the page -- again,
from the <tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_SECONDS</span></tt> setting.</li>
</ul>
<p>See <a class="reference external" href="http/middleware.html#topics-http-middleware"><em>Middleware</em></a> for more on middleware.</p>
<div class="versionadded">
<span class="title">New in Django 1.0.</span> </div>
<p>If a view sets its own cache expiry time (i.e. it has a <tt class="docutils literal"><span class="pre">max-age</span></tt> section in
its <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> header) then the page will be cached until the expiry
time, rather than <tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_SECONDS</span></tt>. Using the decorators in
<tt class="docutils literal"><span class="pre">django.views.decorators.cache</span></tt> you can easily set a view's expiry time
(using the <tt class="docutils literal"><span class="pre">cache_control</span></tt> decorator) or disable caching for a view (using
the <tt class="docutils literal"><span class="pre">never_cache</span></tt> decorator). See the <a class="reference internal" href="#controlling-cache-using-other-headers">using other headers</a> section for
more on these decorators.</p>
</div>
<div class="section" id="s-the-per-view-cache">
<span id="the-per-view-cache"></span><h2>The per-view cache<a class="headerlink" href="#the-per-view-cache" title="Permalink to this headline">¶</a></h2>
<p>A more granular way to use the caching framework is by caching the output of
individual views. <tt class="docutils literal"><span class="pre">django.views.decorators.cache</span></tt> defines a <tt class="docutils literal"><span class="pre">cache_page</span></tt>
decorator that will automatically cache the view's response for you. It's easy
to use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.views.decorators.cache</span> <span class="kn">import</span> <span class="n">cache_page</span>

<span class="k">def</span> <span class="nf">slashdot_this</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>

<span class="n">slashdot_this</span> <span class="o">=</span> <span class="n">cache_page</span><span class="p">(</span><span class="n">slashdot_this</span><span class="p">,</span> <span class="mf">60</span> <span class="o">*</span> <span class="mf">15</span><span class="p">)</span>
</pre></div>
</div>
<p>Or, using Python 2.4's decorator syntax:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@cache_page</span><span class="p">(</span><span class="mf">60</span> <span class="o">*</span> <span class="mf">15</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">slashdot_this</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">cache_page</span></tt> takes a single argument: the cache timeout, in seconds. In the
above example, the result of the <tt class="docutils literal"><span class="pre">slashdot_this()</span></tt> view will be cached for 15
minutes.</p>
</div>
<div class="section" id="s-template-fragment-caching">
<span id="template-fragment-caching"></span><h2>Template fragment caching<a class="headerlink" href="#template-fragment-caching" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<span class="title">New in Django 1.0.</span> </div>
<p>If you're after even more control, you can also cache template fragments using
the <tt class="docutils literal"><span class="pre">cache</span></tt> template tag. To give your template access to this tag, put
<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">load</span> <span class="pre">cache</span> <span class="pre">%}</span></tt> near the top of your template.</p>
<p>The <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">cache</span> <span class="pre">%}</span></tt> template tag caches the contents of the block for a given
amount of time. It takes at least two arguments: the cache timeout, in seconds,
and the name to give the cache fragment. For example:</p>
<div class="highlight-python"><pre>{% load cache %}
{% cache 500 sidebar %}
    .. sidebar ..
{% endcache %}</pre>
</div>
<p>Sometimes you might want to cache multiple copies of a fragment depending on
some dynamic data that appears inside the fragment. For example, you might want a
separate cached copy of the sidebar used in the previous example for every user
of your site. Do this by passing additional arguments to the <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">cache</span> <span class="pre">%}</span></tt>
template tag to uniquely identify the cache fragment:</p>
<div class="highlight-python"><pre>{% load cache %}
{% cache 500 sidebar request.user.username %}
    .. sidebar for logged in user ..
{% endcache %}</pre>
</div>
<p>It's perfectly fine to specify more than one argument to identify the fragment.
Simply pass as many arguments to <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">cache</span> <span class="pre">%}</span></tt> as you need.</p>
<p>The cache timeout can be a template variable, as long as the template variable
resolves to an integer value. For example, if the template variable
<tt class="docutils literal"><span class="pre">my_timeout</span></tt> is set to the value <tt class="docutils literal"><span class="pre">600</span></tt>, then the following two examples are
equivalent:</p>
<div class="highlight-python"><pre>{% cache 600 sidebar %} ... {% endcache %}
{% cache my_timeout sidebar %} ... {% endcache %}</pre>
</div>
<p>This feature is useful in avoiding repetition in templates. You can set the
timeout in a variable, in one place, and just reuse that value.</p>
</div>
<div class="section" id="s-the-low-level-cache-api">
<span id="the-low-level-cache-api"></span><h2>The low-level cache API<a class="headerlink" href="#the-low-level-cache-api" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, however, caching an entire rendered page doesn't gain you very much.
For example, you may find it's only necessary to cache the result of an
intensive database query. In cases like this, you can use the low-level cache
API to store objects in the cache with any level of granularity you like.</p>
<p>The cache API is simple. The cache module, <tt class="docutils literal"><span class="pre">django.core.cache</span></tt>, exports a
<tt class="docutils literal"><span class="pre">cache</span></tt> object that's automatically created from the <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt>
setting:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.core.cache</span> <span class="kn">import</span> <span class="n">cache</span>
</pre></div>
</div>
<p>The basic interface is <tt class="docutils literal"><span class="pre">set(key,</span> <span class="pre">value,</span> <span class="pre">timeout_seconds)</span></tt> and <tt class="docutils literal"><span class="pre">get(key)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;my_key&#39;</span><span class="p">,</span> <span class="s">&#39;hello, world!&#39;</span><span class="p">,</span> <span class="mf">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;my_key&#39;</span><span class="p">)</span>
<span class="go">&#39;hello, world!&#39;</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">timeout_seconds</span></tt> argument is optional and defaults to the <tt class="docutils literal"><span class="pre">timeout</span></tt>
argument in the <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt> setting (explained above).</p>
<p>If the object doesn't exist in the cache, <tt class="docutils literal"><span class="pre">cache.get()</span></tt> returns <tt class="xref docutils literal"><span class="pre">None</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;some_other_key&#39;</span><span class="p">)</span>
<span class="go">None</span>

<span class="go"># Wait 30 seconds for &#39;my_key&#39; to expire...</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;my_key&#39;</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
<p>get() can take a <tt class="docutils literal"><span class="pre">default</span></tt> argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;my_key&#39;</span><span class="p">,</span> <span class="s">&#39;has expired&#39;</span><span class="p">)</span>
<span class="go">&#39;has expired&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<span class="title">New in Django 1.0.</span> </div>
<p>To add a key only if it doesn't already exist, use the <tt class="docutils literal"><span class="pre">add()</span></tt> method.
It takes the same parameters as <tt class="docutils literal"><span class="pre">set()</span></tt>, but it will not attempt to
update the cache if the key specified is already present:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;add_key&#39;</span><span class="p">,</span> <span class="s">&#39;Initial value&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;add_key&#39;</span><span class="p">,</span> <span class="s">&#39;New value&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;add_key&#39;</span><span class="p">)</span>
<span class="go">&#39;Initial value&#39;</span>
</pre></div>
</div>
<p>If you need to know whether <tt class="docutils literal"><span class="pre">add()</span></tt> stored a value in the cache, you can
check the return value. It will return <tt class="xref docutils literal"><span class="pre">True</span></tt> if the value was stored,
<tt class="xref docutils literal"><span class="pre">False</span></tt> otherwise.</p>
<p>There's also a <tt class="docutils literal"><span class="pre">get_many()</span></tt> interface that only hits the cache once.
<tt class="docutils literal"><span class="pre">get_many()</span></tt> returns a dictionary with all the keys you asked for that
actually exist in the cache (and haven't expired):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mf">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mf">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="mf">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get_many</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">])</span>
<span class="go">{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}</span>
</pre></div>
</div>
<p>Finally, you can delete keys explicitly with <tt class="docutils literal"><span class="pre">delete()</span></tt>. This is an easy way
of clearing the cache for a particular object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>That's it. The cache has very few restrictions: You can cache any object that
can be pickled safely, although keys must be strings.</p>
</div>
<div class="section" id="s-upstream-caches">
<span id="upstream-caches"></span><h2>Upstream caches<a class="headerlink" href="#upstream-caches" title="Permalink to this headline">¶</a></h2>
<p>So far, this document has focused on caching your <em>own</em> data. But another type
of caching is relevant to Web development, too: caching performed by &quot;upstream&quot;
caches. These are systems that cache pages for users even before the request
reaches your Web site.</p>
<p>Here are a few examples of upstream caches:</p>
<ul class="simple">
<li>Your ISP may cache certain pages, so if you requested a page from
somedomain.com, your ISP would send you the page without having to access
somedomain.com directly.</li>
<li>Your Django Web site may sit behind a Squid Web proxy
(<a class="reference external" href="http://www.squid-cache.org/">http://www.squid-cache.org/</a>) that caches pages for performance. In this
case, each request first would be handled by Squid, and it'd only be
passed to your application if needed.</li>
<li>Your Web browser caches pages, too. If a Web page sends out the right
headers, your browser will use the local (cached) copy for subsequent
requests to that page.</li>
</ul>
<p>Upstream caching is a nice efficiency boost, but there's a danger to it:
Many Web pages' contents differ based on authentication and a host of other
variables, and cache systems that blindly save pages based purely on URLs could
expose incorrect or sensitive data to subsequent visitors to those pages.</p>
<p>For example, say you operate a Web e-mail system, and the contents of the
&quot;inbox&quot; page obviously depend on which user is logged in. If an ISP blindly
cached your site, then the first user who logged in through that ISP would have
his user-specific inbox page cached for subsequent visitors to the site. That's
not cool.</p>
<p>Fortunately, HTTP provides a solution to this problem: A set of HTTP headers
exist to instruct caching mechanisms to differ their cache contents depending
on designated variables, and to tell caching mechanisms not to cache particular
pages.</p>
</div>
<div class="section" id="s-using-vary-headers">
<span id="using-vary-headers"></span><h2>Using Vary headers<a class="headerlink" href="#using-vary-headers" title="Permalink to this headline">¶</a></h2>
<p>One of these headers is <tt class="docutils literal"><span class="pre">Vary</span></tt>. It defines which request headers a cache
mechanism should take into account when building its cache key. For example, if
the contents of a Web page depend on a user's language preference, the page is
said to &quot;vary on language.&quot;</p>
<p>By default, Django's cache system creates its cache keys using the requested
path -- e.g., <tt class="docutils literal"><span class="pre">&quot;/stories/2005/jun/23/bank_robbed/&quot;</span></tt>. This means every request
to that URL will use the same cached version, regardless of user-agent
differences such as cookies or language preferences.</p>
<p>That's where <tt class="docutils literal"><span class="pre">Vary</span></tt> comes in.</p>
<p>If your Django-powered page outputs different content based on some difference
in request headers -- such as a cookie, or language, or user-agent -- you'll
need to use the <tt class="docutils literal"><span class="pre">Vary</span></tt> header to tell caching mechanisms that the page output
depends on those things.</p>
<p>To do this in Django, use the convenient <tt class="docutils literal"><span class="pre">vary_on_headers</span></tt> view decorator,
like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.views.decorators.vary</span> <span class="kn">import</span> <span class="n">vary_on_headers</span>

<span class="c"># Python 2.3 syntax.</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
<span class="n">my_view</span> <span class="o">=</span> <span class="n">vary_on_headers</span><span class="p">(</span><span class="n">my_view</span><span class="p">,</span> <span class="s">&#39;User-Agent&#39;</span><span class="p">)</span>

<span class="c"># Python 2.4 decorator syntax.</span>
<span class="nd">@vary_on_headers</span><span class="p">(</span><span class="s">&#39;User-Agent&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>In this case, a caching mechanism (such as Django's own cache middleware) will
cache a separate version of the page for each unique user-agent.</p>
<p>The advantage to using the <tt class="docutils literal"><span class="pre">vary_on_headers</span></tt> decorator rather than manually
setting the <tt class="docutils literal"><span class="pre">Vary</span></tt> header (using something like
<tt class="docutils literal"><span class="pre">response['Vary']</span> <span class="pre">=</span> <span class="pre">'user-agent'</span></tt>) is that the decorator adds to the <tt class="docutils literal"><span class="pre">Vary</span></tt>
header (which may already exist) rather than setting it from scratch.</p>
<p>You can pass multiple headers to <tt class="docutils literal"><span class="pre">vary_on_headers()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@vary_on_headers</span><span class="p">(</span><span class="s">&#39;User-Agent&#39;</span><span class="p">,</span> <span class="s">&#39;Cookie&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Because varying on cookie is such a common case, there's a <tt class="docutils literal"><span class="pre">vary_on_cookie</span></tt>
decorator. These two views are equivalent:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@vary_on_cookie</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>

<span class="nd">@vary_on_headers</span><span class="p">(</span><span class="s">&#39;Cookie&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Also note that the headers you pass to <tt class="docutils literal"><span class="pre">vary_on_headers</span></tt> are not case
sensitive. <tt class="docutils literal"><span class="pre">&quot;User-Agent&quot;</span></tt> is the same thing as <tt class="docutils literal"><span class="pre">&quot;user-agent&quot;</span></tt>.</p>
<p>You can also use a helper function, <tt class="docutils literal"><span class="pre">django.utils.cache.patch_vary_headers</span></tt>,
directly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.utils.cache</span> <span class="kn">import</span> <span class="n">patch_vary_headers</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">render_to_response</span><span class="p">(</span><span class="s">&#39;template_name&#39;</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
    <span class="n">patch_vary_headers</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;Cookie&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">response</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">patch_vary_headers</span></tt> takes an <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> instance as its first argument
and a list/tuple of header names as its second argument.</p>
<p>For more on Vary headers, see the <a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44">official Vary spec</a>.</p>
</div>
<div class="section" id="s-controlling-cache-using-other-headers">
<span id="controlling-cache-using-other-headers"></span><h2>Controlling cache: Using other headers<a class="headerlink" href="#controlling-cache-using-other-headers" title="Permalink to this headline">¶</a></h2>
<p>Another problem with caching is the privacy of data and the question of where
data should be stored in a cascade of caches.</p>
<p>A user usually faces two kinds of caches: his own browser cache (a private
cache) and his provider's cache (a public cache). A public cache is used by
multiple users and controlled by someone else. This poses problems with
sensitive data: You don't want, say, your banking-account number stored in a
public cache. So Web applications need a way to tell caches which data is
private and which is public.</p>
<p>The solution is to indicate a page's cache should be &quot;private.&quot; To do this in
Django, use the <tt class="docutils literal"><span class="pre">cache_control</span></tt> view decorator. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.views.decorators.cache</span> <span class="kn">import</span> <span class="n">cache_control</span>
<span class="nd">@cache_control</span><span class="p">(</span><span class="n">private</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This decorator takes care of sending out the appropriate HTTP header behind the
scenes.</p>
<p>There are a few other ways to control cache parameters. For example, HTTP
allows applications to do the following:</p>
<ul class="simple">
<li>Define the maximum time a page should be cached.</li>
<li>Specify whether a cache should always check for newer versions, only
delivering the cached content when there are no changes. (Some caches
might deliver cached content even if the server page changed -- simply
because the cache copy isn't yet expired.)</li>
</ul>
<p>In Django, use the <tt class="docutils literal"><span class="pre">cache_control</span></tt> view decorator to specify these cache
parameters. In this example, <tt class="docutils literal"><span class="pre">cache_control</span></tt> tells caches to revalidate the
cache on every access and to store cached versions for, at most, 3600 seconds:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.views.decorators.cache</span> <span class="kn">import</span> <span class="n">cache_control</span>
<span class="nd">@cache_control</span><span class="p">(</span><span class="n">must_revalidate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">max_age</span><span class="o">=</span><span class="mf">3600</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Any valid <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> HTTP directive is valid in <tt class="docutils literal"><span class="pre">cache_control()</span></tt>.
Here's a full list:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">public=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">private=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">no_cache=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">no_transform=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">must_revalidate=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">proxy_revalidate=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">max_age=num_seconds</span></tt></li>
<li><tt class="docutils literal"><span class="pre">s_maxage=num_seconds</span></tt></li>
</ul>
<p>For explanation of Cache-Control HTTP directives, see the <a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">Cache-Control spec</a>.</p>
<p>(Note that the caching middleware already sets the cache header's max-age with
the value of the <tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_SETTINGS</span></tt> setting. If you use a custom
<tt class="docutils literal"><span class="pre">max_age</span></tt> in a <tt class="docutils literal"><span class="pre">cache_control</span></tt> decorator, the decorator will take
precedence, and the header values will be merged correctly.)</p>
<p>If you want to use headers to disable caching altogether,
<tt class="docutils literal"><span class="pre">django.views.decorators.cache.never_cache</span></tt> is a view decorator that adds
headers to ensure the response won't be cached by browsers or other caches. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.views.decorators.cache</span> <span class="kn">import</span> <span class="n">never_cache</span>
<span class="nd">@never_cache</span>
<span class="k">def</span> <span class="nf">myview</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="s-other-optimizations">
<span id="other-optimizations"></span><h2>Other optimizations<a class="headerlink" href="#other-optimizations" title="Permalink to this headline">¶</a></h2>
<p>Django comes with a few other pieces of middleware that can help optimize your
apps' performance:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">django.middleware.http.ConditionalGetMiddleware</span></tt> adds support for
conditional GET. This makes use of <tt class="docutils literal"><span class="pre">ETag</span></tt> and <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>
headers.</li>
<li><tt class="docutils literal"><span class="pre">django.middleware.gzip.GZipMiddleware</span></tt> compresses content for browsers
that understand gzip compression (all modern browsers).</li>
</ul>
</div>
<div class="section" id="s-order-of-middleware-classes">
<span id="order-of-middleware-classes"></span><h2>Order of MIDDLEWARE_CLASSES<a class="headerlink" href="#order-of-middleware-classes" title="Permalink to this headline">¶</a></h2>
<p>If you use caching middleware, it's important to put each half in the right
place within the <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> setting. That's because the cache
middleware needs to know which headers by which to vary the cache storage.
Middleware always adds something to the <tt class="docutils literal"><span class="pre">Vary</span></tt> response header when it can.</p>
<p><tt class="docutils literal"><span class="pre">UpdateCacheMiddleware</span></tt> runs during the response phase, where middleware is
run in reverse order, so an item at the top of the list runs <em>last</em> during the
response phase. Thus, you need to make sure that <tt class="docutils literal"><span class="pre">UpdateCacheMiddleware</span></tt>
appears <em>before</em> any other middleware that might add something to the <tt class="docutils literal"><span class="pre">Vary</span></tt>
header. The following middleware modules do so:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SessionMiddleware</span></tt> adds <tt class="docutils literal"><span class="pre">Cookie</span></tt></li>
<li><tt class="docutils literal"><span class="pre">GZipMiddleware</span></tt> adds <tt class="docutils literal"><span class="pre">Accept-Encoding</span></tt></li>
<li><tt class="docutils literal"><span class="pre">LocaleMiddleware</span></tt> adds <tt class="docutils literal"><span class="pre">Accept-Language</span></tt></li>
</ul>
<p><tt class="docutils literal"><span class="pre">FetchFromCacheMiddleware</span></tt>, on the other hand, runs during the request phase,
where middleware is applied first-to-last, so an item at the top of the list
runs <em>first</em> during the request phase. The <tt class="docutils literal"><span class="pre">FetchFromCacheMiddleware</span></tt> also
needs to run after other middleware updates the <tt class="docutils literal"><span class="pre">Vary</span></tt> header, so
<tt class="docutils literal"><span class="pre">FetchFromCacheMiddleware</span></tt> must be <em>after</em> any item that does so.</p>
</div>
</div>


          </div>         
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../contents.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="">Django&#8217;s cache framework</a><ul>
<li><a class="reference external" href="#setting-up-the-cache">Setting up the cache</a><ul>
<li><a class="reference external" href="#memcached">Memcached</a></li>
<li><a class="reference external" href="#database-caching">Database caching</a></li>
<li><a class="reference external" href="#filesystem-caching">Filesystem caching</a></li>
<li><a class="reference external" href="#local-memory-caching">Local-memory caching</a></li>
<li><a class="reference external" href="#dummy-caching-for-development">Dummy caching (for development)</a></li>
<li><a class="reference external" href="#using-a-custom-cache-backend">Using a custom cache backend</a></li>
<li><a class="reference external" href="#cache-backend-arguments">CACHE_BACKEND arguments</a></li>
</ul>
</li>
<li><a class="reference external" href="#the-per-site-cache">The per-site cache</a></li>
<li><a class="reference external" href="#the-per-view-cache">The per-view cache</a></li>
<li><a class="reference external" href="#template-fragment-caching">Template fragment caching</a></li>
<li><a class="reference external" href="#the-low-level-cache-api">The low-level cache API</a></li>
<li><a class="reference external" href="#upstream-caches">Upstream caches</a></li>
<li><a class="reference external" href="#using-vary-headers">Using Vary headers</a></li>
<li><a class="reference external" href="#controlling-cache-using-other-headers">Controlling cache: Using other headers</a></li>
<li><a class="reference external" href="#other-optimizations">Other optimizations</a></li>
<li><a class="reference external" href="#order-of-middleware-classes">Order of MIDDLEWARE_CLASSES</a></li>
</ul>
</li>
</ul>

  <h3>Browse</h3>
  <ul>
    
      <li>Prev: <a href="auth.html">User authentication in Django</a></li>
    
    
      <li>Next: <a href="email.html">Sending e-mail</a></li>
    
  </ul>
  <h3>You are here:</h3>
  <ul>
      <li>
        <a href="../index.html">Django v1.0 documentation</a>
        
          <ul><li><a href="index.html">Using Django</a>
        
        <ul><li>Django&#8217;s cache framework</li></ul>
        </li></ul>
      </li>
  </ul>  

            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/topics/cache.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">Jan 06, 2009</p>
          </div> 
        
      
    </div>
    
    <div id="ft">
      <div class="nav">
    &laquo; <a href="auth.html" title="User authentication in Django">previous</a> 
     |
    <a href="index.html" title="Using Django" accesskey="U">up</a>
   |
    <a href="email.html" title="Sending e-mail">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>