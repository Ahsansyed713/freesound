#
# Freesound is (c) MUSIC TECHNOLOGY GROUP, UNIVERSITAT POMPEU FABRA
#
# Freesound is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Freesound is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     See AUTHORS file.
#

ALLOWED_CONTENT_BASED_SEARCH_DESCRIPTORS = [
 '.lowlevel.average_loudness',
 '.lowlevel.barkbands.dmean',
 '.lowlevel.barkbands.dmean2',
 '.lowlevel.barkbands.dvar',
 '.lowlevel.barkbands.dvar2',
 '.lowlevel.barkbands.max',
 '.lowlevel.barkbands.mean',
 '.lowlevel.barkbands.min',
 '.lowlevel.barkbands.var',
 '.lowlevel.barkbands_kurtosis.dmean',
 '.lowlevel.barkbands_kurtosis.dmean2',
 '.lowlevel.barkbands_kurtosis.dvar',
 '.lowlevel.barkbands_kurtosis.dvar2',
 '.lowlevel.barkbands_kurtosis.max',
 '.lowlevel.barkbands_kurtosis.mean',
 '.lowlevel.barkbands_kurtosis.min',
 '.lowlevel.barkbands_kurtosis.var',
 '.lowlevel.barkbands_skewness.dmean',
 '.lowlevel.barkbands_skewness.dmean2',
 '.lowlevel.barkbands_skewness.dvar',
 '.lowlevel.barkbands_skewness.dvar2',
 '.lowlevel.barkbands_skewness.max',
 '.lowlevel.barkbands_skewness.mean',
 '.lowlevel.barkbands_skewness.min',
 '.lowlevel.barkbands_skewness.var',
 '.lowlevel.barkbands_spread.dmean',
 '.lowlevel.barkbands_spread.dmean2',
 '.lowlevel.barkbands_spread.dvar',
 '.lowlevel.barkbands_spread.dvar2',
 '.lowlevel.barkbands_spread.max',
 '.lowlevel.barkbands_spread.mean',
 '.lowlevel.barkbands_spread.min',
 '.lowlevel.barkbands_spread.var',
 '.lowlevel.dissonance.dmean',
 '.lowlevel.dissonance.dmean2',
 '.lowlevel.dissonance.dvar',
 '.lowlevel.dissonance.dvar2',
 '.lowlevel.dissonance.max',
 '.lowlevel.dissonance.mean',
 '.lowlevel.dissonance.min',
 '.lowlevel.dissonance.var',
 '.lowlevel.frequency_bands.dmean',
 '.lowlevel.frequency_bands.dmean2',
 '.lowlevel.frequency_bands.dvar',
 '.lowlevel.frequency_bands.dvar2',
 '.lowlevel.frequency_bands.max',
 '.lowlevel.frequency_bands.mean',
 '.lowlevel.frequency_bands.min',
 '.lowlevel.frequency_bands.var',
 '.lowlevel.hfc.dmean',
 '.lowlevel.hfc.dmean2',
 '.lowlevel.hfc.dvar',
 '.lowlevel.hfc.dvar2',
 '.lowlevel.hfc.max',
 '.lowlevel.hfc.mean',
 '.lowlevel.hfc.min',
 '.lowlevel.hfc.var',
 '.lowlevel.mfcc.dmean',
 '.lowlevel.mfcc.dmean2',
 '.lowlevel.mfcc.dvar',
 '.lowlevel.mfcc.dvar2',
 '.lowlevel.mfcc.max',
 '.lowlevel.mfcc.mean',
 '.lowlevel.mfcc.min',
 '.lowlevel.mfcc.var',
 '.lowlevel.pitch.dmean',
 '.lowlevel.pitch.dmean2',
 '.lowlevel.pitch.dvar',
 '.lowlevel.pitch.dvar2',
 '.lowlevel.pitch.max',
 '.lowlevel.pitch.mean',
 '.lowlevel.pitch.min',
 '.lowlevel.pitch.var',
 '.lowlevel.pitch_instantaneous_confidence.dmean',
 '.lowlevel.pitch_instantaneous_confidence.dmean2',
 '.lowlevel.pitch_instantaneous_confidence.dvar',
 '.lowlevel.pitch_instantaneous_confidence.dvar2',
 '.lowlevel.pitch_instantaneous_confidence.max',
 '.lowlevel.pitch_instantaneous_confidence.mean',
 '.lowlevel.pitch_instantaneous_confidence.min',
 '.lowlevel.pitch_instantaneous_confidence.var',
 '.lowlevel.pitch_salience.dmean',
 '.lowlevel.pitch_salience.dmean2',
 '.lowlevel.pitch_salience.dvar',
 '.lowlevel.pitch_salience.dvar2',
 '.lowlevel.pitch_salience.max',
 '.lowlevel.pitch_salience.mean',
 '.lowlevel.pitch_salience.min',
 '.lowlevel.pitch_salience.var',
 '.lowlevel.scvalleys.dmean',
 '.lowlevel.scvalleys.dmean2',
 '.lowlevel.scvalleys.dvar',
 '.lowlevel.scvalleys.dvar2',
 '.lowlevel.scvalleys.max',
 '.lowlevel.scvalleys.mean',
 '.lowlevel.scvalleys.min',
 '.lowlevel.scvalleys.var',
 '.lowlevel.silence_rate_20dB.dmean',
 '.lowlevel.silence_rate_20dB.dmean2',
 '.lowlevel.silence_rate_20dB.dvar',
 '.lowlevel.silence_rate_20dB.dvar2',
 '.lowlevel.silence_rate_20dB.max',
 '.lowlevel.silence_rate_20dB.mean',
 '.lowlevel.silence_rate_20dB.min',
 '.lowlevel.silence_rate_20dB.var',
 '.lowlevel.silence_rate_30dB.dmean',
 '.lowlevel.silence_rate_30dB.dmean2',
 '.lowlevel.silence_rate_30dB.dvar',
 '.lowlevel.silence_rate_30dB.dvar2',
 '.lowlevel.silence_rate_30dB.max',
 '.lowlevel.silence_rate_30dB.mean',
 '.lowlevel.silence_rate_30dB.min',
 '.lowlevel.silence_rate_30dB.var',
 '.lowlevel.silence_rate_60dB.dmean',
 '.lowlevel.silence_rate_60dB.dmean2',
 '.lowlevel.silence_rate_60dB.dvar',
 '.lowlevel.silence_rate_60dB.dvar2',
 '.lowlevel.silence_rate_60dB.max',
 '.lowlevel.silence_rate_60dB.mean',
 '.lowlevel.silence_rate_60dB.min',
 '.lowlevel.silence_rate_60dB.var',
 '.lowlevel.spectral_centroid.dmean',
 '.lowlevel.spectral_centroid.dmean2',
 '.lowlevel.spectral_centroid.dvar',
 '.lowlevel.spectral_centroid.dvar2',
 '.lowlevel.spectral_centroid.max',
 '.lowlevel.spectral_centroid.mean',
 '.lowlevel.spectral_centroid.min',
 '.lowlevel.spectral_centroid.var',
 '.lowlevel.spectral_complexity.dmean',
 '.lowlevel.spectral_complexity.dmean2',
 '.lowlevel.spectral_complexity.dvar',
 '.lowlevel.spectral_complexity.dvar2',
 '.lowlevel.spectral_complexity.max',
 '.lowlevel.spectral_complexity.mean',
 '.lowlevel.spectral_complexity.min',
 '.lowlevel.spectral_complexity.var',
 '.lowlevel.spectral_contrast.dmean',
 '.lowlevel.spectral_contrast.dmean2',
 '.lowlevel.spectral_contrast.dvar',
 '.lowlevel.spectral_contrast.dvar2',
 '.lowlevel.spectral_contrast.max',
 '.lowlevel.spectral_contrast.mean',
 '.lowlevel.spectral_contrast.min',
 '.lowlevel.spectral_contrast.var',
 '.lowlevel.spectral_crest.dmean',
 '.lowlevel.spectral_crest.dmean2',
 '.lowlevel.spectral_crest.dvar',
 '.lowlevel.spectral_crest.dvar2',
 '.lowlevel.spectral_crest.max',
 '.lowlevel.spectral_crest.mean',
 '.lowlevel.spectral_crest.min',
 '.lowlevel.spectral_crest.var',
 '.lowlevel.spectral_decrease.dmean',
 '.lowlevel.spectral_decrease.dmean2',
 '.lowlevel.spectral_decrease.max',
 '.lowlevel.spectral_decrease.mean',
 '.lowlevel.spectral_decrease.min',
 '.lowlevel.spectral_energy.dmean',
 '.lowlevel.spectral_energy.dmean2',
 '.lowlevel.spectral_energy.dvar',
 '.lowlevel.spectral_energy.dvar2',
 '.lowlevel.spectral_energy.max',
 '.lowlevel.spectral_energy.mean',
 '.lowlevel.spectral_energy.min',
 '.lowlevel.spectral_energy.var',
 '.lowlevel.spectral_energyband_high.dmean',
 '.lowlevel.spectral_energyband_high.dmean2',
 '.lowlevel.spectral_energyband_high.dvar',
 '.lowlevel.spectral_energyband_high.dvar2',
 '.lowlevel.spectral_energyband_high.max',
 '.lowlevel.spectral_energyband_high.mean',
 '.lowlevel.spectral_energyband_high.min',
 '.lowlevel.spectral_energyband_high.var',
 '.lowlevel.spectral_energyband_low.dmean',
 '.lowlevel.spectral_energyband_low.dmean2',
 '.lowlevel.spectral_energyband_low.dvar',
 '.lowlevel.spectral_energyband_low.dvar2',
 '.lowlevel.spectral_energyband_low.max',
 '.lowlevel.spectral_energyband_low.mean',
 '.lowlevel.spectral_energyband_low.min',
 '.lowlevel.spectral_energyband_low.var',
 '.lowlevel.spectral_energyband_middle_high.dmean',
 '.lowlevel.spectral_energyband_middle_high.dmean2',
 '.lowlevel.spectral_energyband_middle_high.dvar',
 '.lowlevel.spectral_energyband_middle_high.dvar2',
 '.lowlevel.spectral_energyband_middle_high.max',
 '.lowlevel.spectral_energyband_middle_high.mean',
 '.lowlevel.spectral_energyband_middle_high.min',
 '.lowlevel.spectral_energyband_middle_high.var',
 '.lowlevel.spectral_energyband_middle_low.dmean',
 '.lowlevel.spectral_energyband_middle_low.dmean2',
 '.lowlevel.spectral_energyband_middle_low.dvar',
 '.lowlevel.spectral_energyband_middle_low.dvar2',
 '.lowlevel.spectral_energyband_middle_low.max',
 '.lowlevel.spectral_energyband_middle_low.mean',
 '.lowlevel.spectral_energyband_middle_low.min',
 '.lowlevel.spectral_energyband_middle_low.var',
 '.lowlevel.spectral_flatness_db.dmean',
 '.lowlevel.spectral_flatness_db.dmean2',
 '.lowlevel.spectral_flatness_db.dvar',
 '.lowlevel.spectral_flatness_db.dvar2',
 '.lowlevel.spectral_flatness_db.max',
 '.lowlevel.spectral_flatness_db.mean',
 '.lowlevel.spectral_flatness_db.min',
 '.lowlevel.spectral_flatness_db.var',
 '.lowlevel.spectral_flux.dmean',
 '.lowlevel.spectral_flux.dmean2',
 '.lowlevel.spectral_flux.dvar',
 '.lowlevel.spectral_flux.dvar2',
 '.lowlevel.spectral_flux.max',
 '.lowlevel.spectral_flux.mean',
 '.lowlevel.spectral_flux.min',
 '.lowlevel.spectral_flux.var',
 '.lowlevel.spectral_kurtosis.dmean',
 '.lowlevel.spectral_kurtosis.dmean2',
 '.lowlevel.spectral_kurtosis.dvar',
 '.lowlevel.spectral_kurtosis.dvar2',
 '.lowlevel.spectral_kurtosis.max',
 '.lowlevel.spectral_kurtosis.mean',
 '.lowlevel.spectral_kurtosis.min',
 '.lowlevel.spectral_kurtosis.var',
 '.lowlevel.spectral_rms.dmean',
 '.lowlevel.spectral_rms.dmean2',
 '.lowlevel.spectral_rms.dvar',
 '.lowlevel.spectral_rms.dvar2',
 '.lowlevel.spectral_rms.max',
 '.lowlevel.spectral_rms.mean',
 '.lowlevel.spectral_rms.min',
 '.lowlevel.spectral_rms.var',
 '.lowlevel.spectral_rolloff.dmean',
 '.lowlevel.spectral_rolloff.dmean2',
 '.lowlevel.spectral_rolloff.dvar',
 '.lowlevel.spectral_rolloff.dvar2',
 '.lowlevel.spectral_rolloff.max',
 '.lowlevel.spectral_rolloff.mean',
 '.lowlevel.spectral_rolloff.min',
 '.lowlevel.spectral_rolloff.var',
 '.lowlevel.spectral_skewness.dmean',
 '.lowlevel.spectral_skewness.dmean2',
 '.lowlevel.spectral_skewness.dvar',
 '.lowlevel.spectral_skewness.dvar2',
 '.lowlevel.spectral_skewness.max',
 '.lowlevel.spectral_skewness.mean',
 '.lowlevel.spectral_skewness.min',
 '.lowlevel.spectral_skewness.var',
 '.lowlevel.spectral_spread.dmean',
 '.lowlevel.spectral_spread.dmean2',
 '.lowlevel.spectral_spread.dvar',
 '.lowlevel.spectral_spread.dvar2',
 '.lowlevel.spectral_spread.max',
 '.lowlevel.spectral_spread.mean',
 '.lowlevel.spectral_spread.min',
 '.lowlevel.spectral_spread.var',
 '.lowlevel.spectral_strongpeak.dmean',
 '.lowlevel.spectral_strongpeak.dmean2',
 '.lowlevel.spectral_strongpeak.dvar',
 '.lowlevel.spectral_strongpeak.dvar2',
 '.lowlevel.spectral_strongpeak.max',
 '.lowlevel.spectral_strongpeak.mean',
 '.lowlevel.spectral_strongpeak.min',
 '.lowlevel.spectral_strongpeak.var',
 '.lowlevel.zerocrossingrate.dmean',
 '.lowlevel.zerocrossingrate.dmean2',
 '.lowlevel.zerocrossingrate.dvar',
 '.lowlevel.zerocrossingrate.dvar2',
 '.lowlevel.zerocrossingrate.max',
 '.lowlevel.zerocrossingrate.mean',
 '.lowlevel.zerocrossingrate.min',
 '.lowlevel.zerocrossingrate.var',
 '.metadata.version.essentia',
 '.rhythm.beats_loudness.dmean',
 '.rhythm.beats_loudness.dmean2',
 '.rhythm.beats_loudness.dvar',
 '.rhythm.beats_loudness.dvar2',
 '.rhythm.beats_loudness.max',
 '.rhythm.beats_loudness.mean',
 '.rhythm.beats_loudness.min',
 '.rhythm.beats_loudness.var',
 '.rhythm.beats_loudness_band_ratio.dmean',
 '.rhythm.beats_loudness_band_ratio.dmean2',
 '.rhythm.beats_loudness_band_ratio.dvar',
 '.rhythm.beats_loudness_band_ratio.dvar2',
 '.rhythm.beats_loudness_band_ratio.max',
 '.rhythm.beats_loudness_band_ratio.mean',
 '.rhythm.beats_loudness_band_ratio.min',
 '.rhythm.beats_loudness_band_ratio.var',
 '.rhythm.bpm',
 '.rhythm.first_peak_bpm',
 '.rhythm.first_peak_spread',
 '.rhythm.first_peak_weight',
 '.rhythm.second_peak_bpm',
 '.rhythm.second_peak_spread',
 '.rhythm.second_peak_weight',
 '.sfx.der_av_after_max.max',
 '.sfx.der_av_after_max.mean',
 '.sfx.der_av_after_max.min',
 '.sfx.effective_duration.max',
 '.sfx.effective_duration.mean',
 '.sfx.effective_duration.min',
 '.sfx.flatness.max',
 '.sfx.flatness.mean',
 '.sfx.flatness.min',
 '.sfx.logattacktime.max',
 '.sfx.logattacktime.mean',
 '.sfx.logattacktime.min',
 '.sfx.max_der_before_max.max',
 '.sfx.max_der_before_max.mean',
 '.sfx.max_der_before_max.min',
 '.sfx.max_to_total',
 '.sfx.pitch_after_max_to_before_max_energy_ratio',
 '.sfx.pitch_centroid',
 '.sfx.pitch_max_to_total',
 '.sfx.pitch_min_to_total',
 '.sfx.strongdecay',
 '.sfx.tc_to_total',
 '.sfx.temporal_centroid.max',
 '.sfx.temporal_centroid.mean',
 '.sfx.temporal_centroid.min',
 '.sfx.temporal_decrease.max',
 '.sfx.temporal_decrease.mean',
 '.sfx.temporal_decrease.min',
 '.sfx.temporal_kurtosis.max',
 '.sfx.temporal_kurtosis.mean',
 '.sfx.temporal_kurtosis.min',
 '.sfx.temporal_skewness.max',
 '.sfx.temporal_skewness.mean',
 '.sfx.temporal_skewness.min',
 '.sfx.temporal_spread.max',
 '.sfx.temporal_spread.mean',
 '.sfx.temporal_spread.min',
 '.tonal.chords_changes_rate',
 '.tonal.chords_histogram',
 '.tonal.chords_key',
 '.tonal.chords_number_rate',
 '.tonal.chords_scale',
 '.tonal.chords_strength.dmean',
 '.tonal.chords_strength.dmean2',
 '.tonal.chords_strength.dvar',
 '.tonal.chords_strength.dvar2',
 '.tonal.chords_strength.max',
 '.tonal.chords_strength.mean',
 '.tonal.chords_strength.min',
 '.tonal.chords_strength.var',
 '.tonal.hpcp.dmean',
 '.tonal.hpcp.dmean2',
 '.tonal.hpcp.dvar',
 '.tonal.hpcp.dvar2',
 '.tonal.hpcp.max',
 '.tonal.hpcp.mean',
 '.tonal.hpcp.min',
 '.tonal.hpcp.var',
 '.tonal.hpcp_highres.dmean',
 '.tonal.hpcp_highres.dmean2',
 '.tonal.hpcp_highres.dvar',
 '.tonal.hpcp_highres.dvar2',
 '.tonal.hpcp_highres.max',
 '.tonal.hpcp_highres.mean',
 '.tonal.hpcp_highres.min',
 '.tonal.hpcp_highres.var',
 '.tonal.key_key',
 '.tonal.key_scale',
 '.tonal.key_strength',
 '.tonal.tuning_frequency.dmean',
 '.tonal.tuning_frequency.dmean2',
 '.tonal.tuning_frequency.dvar',
 '.tonal.tuning_frequency.dvar2',
 '.tonal.tuning_frequency.max',
 '.tonal.tuning_frequency.mean',
 '.tonal.tuning_frequency.min',
 '.tonal.tuning_frequency.var']


def parse_filter(filter_string):

    operators = ['OR','AND','(',')']

    # Find ':'
    filter_struct = []

    min_pos = 0
    while filter_string.find(':',min_pos) != -1:
        current_pos = filter_string.find(':',min_pos)
        min_pos = current_pos + 1

        # Left part (feature name)
        previous_space_pos = filter_string.rfind(' ',0,current_pos)
        feature_name = filter_string[previous_space_pos+1:current_pos]

        # Right part (value, range)
        if filter_string[current_pos+1] == '[':
            next_space_pos = current_pos + 1
            for i in range(0,3):
                next_space_pos = filter_string.find(' ',next_space_pos + 1)
            right_part = filter_string[current_pos+2:next_space_pos]
            type_val = "RANGE"

        elif filter_string[current_pos+1] == '"':
            next_quote_pos = filter_string.find('"',current_pos + 2)
            right_part = filter_string[current_pos+1:next_quote_pos+1]
            type_val = "STRING"
        else:
            next_space_pos = filter_string.find(' ',current_pos + 1)
            if next_space_pos == -1:
                next_space_pos = len(filter_string)
            right_part = filter_string[current_pos+1:next_space_pos + 1]
            if not "," in right_part:
                type_val = "NUMBER"
            else:
                type_val = "ARRAY"

        for op in operators:
            feature_name = feature_name.replace(op,"")
            right_part = right_part.replace(op,"")

        if feature_name not in ALLOWED_CONTENT_BASED_SEARCH_DESCRIPTORS:
            return 'Filter error: At least one feature name does not match with any descirptor name in our database (' + str(feature_name) + '). '

        filter_struct.append({'feature':feature_name,'type':type_val,'value':right_part,'delimiter_position':current_pos,'id':len(filter_struct)+1})

    # Find OPERATORS clauses
    aux_ops = {}
    for op in operators:
        min_pos = 0
        while filter_string.find(op,min_pos) != -1:
            current_pos = filter_string.find(op,min_pos)
            min_pos = current_pos + 1
            aux_ops[current_pos] = op#.append({'op':op,'pos':current_pos})
    keylist = aux_ops.keys()
    keylist.sort()
    for key in keylist:
        op = aux_ops[key]
        current_pos = key

        # Insert OPERATOR clause in appropiate place of filter_struct
        for i,f in enumerate(filter_struct):
            if type(f) == dict:
                if f['delimiter_position'] > current_pos:
                    filter_struct.insert(i,op)
                    break
        if filter_struct[-1]['delimiter_position'] < current_pos:
            filter_struct.append(op)

    # Add AND operators by default (only where there are no other operators between two features)
    final_filter_struct = []
    for i in range(0,len(filter_struct)):
        if i < len(filter_struct) -1:
            if type(filter_struct[i]) == dict and type(filter_struct[i+1]) == dict:
                final_filter_struct.append(filter_struct[i])
                final_filter_struct.append('AND')
            elif type(filter_struct[i]) == dict and filter_struct[i+1] == "(":
                final_filter_struct.append(filter_struct[i])
                final_filter_struct.append('AND')
            elif filter_struct[i] == ")" and type(filter_struct[i+1]) == dict:
                final_filter_struct.append(filter_struct[i])
                final_filter_struct.append('AND')
            else:
                final_filter_struct.append(filter_struct[i])
        else:
            final_filter_struct.append(filter_struct[i])

    # Check good pairing of parenthesis
    if final_filter_struct.count("(") != final_filter_struct.count(")"):
        return "Bad filter syntax."

    # Change values for corrent types
    for f in final_filter_struct:
        if type(f) == dict:
            if f['type'] == 'NUMBER':
                f['value'] = float(f['value'])
            elif f['type'] == 'ARRAY':
                f['value'] = [float(x) for x in f['value'].split(',')]
            elif f['type'] == 'STRING':
                f['value'] = str(f['value'].replace('sharp','#'))
            elif f['type'] == 'RANGE':
                min_str = f['value'][:f['value'].find("TO")-1]
                if min_str != "*":
                    min_v = float(min_str)
                else:
                    min_v = None
                max_str = f['value'][f['value'].find("TO")+3:].replace(']','')
                if max_str != "*":
                    max_v = float(max_str)
                else:
                    max_v = None
                f['value'] = {'min':min_v,'max':max_v}

    return final_filter_struct


def parse_target(target_string):
    target_struct = {}

    min_pos = 0
    while target_string.find(':',min_pos) != -1:
        current_pos = target_string.find(':',min_pos)
        min_pos = current_pos + 1

        # Left part (feature name)
        previous_space_pos = target_string.rfind(' ',0,current_pos)
        feature_name = target_string[previous_space_pos+1:current_pos]

        if feature_name not in ALLOWED_CONTENT_BASED_SEARCH_DESCRIPTORS:
            return 'Target error: At least one feature name does not match with any descirptor name in our database (' + str(feature_name) + '). '

        # Right part
        next_space_pos = target_string.find(' ',current_pos + 1)
        if next_space_pos == -1:
            next_space_pos = len(target_string)
        right_part = target_string[current_pos+1:next_space_pos + 1]
        if not "," in right_part:
            value = float(right_part)
        else:
            value = [float(x) for x in right_part.split(',')]

        target_struct[feature_name] = value

    return target_struct
